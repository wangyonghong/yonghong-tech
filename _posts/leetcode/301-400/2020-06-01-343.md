---
title: LeetCode 343. 整数拆分
key: leetcode-343
permalink: /leetcode/343/
date: 2020-06-01
tags:
- math
- dynamic-programming
description: 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
---

## 题目详情

给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

**示例 1:**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

**说明:** 你可以假设 *n* 不小于 2 且不大于 58。

<!--more-->

## 题解

### 抽象

> 数学是一门非常抽象的学科，同时也很方便我们抽象问题。为了显得我的题解比较高级，引入一些你们看不懂的数学符号也是很有必要的（开玩笑，没有什么高级数学符号啦）。

> 实际上这道题可以用纯数学角度来解，但是我相信大多数人并不想看。即使你看了，大多人的感受也是“好 nb，然而并没有什么用”。

这道题抽象一下就是：

令：
![img](https://up-img.yonghong.tech/pic/2020/05/31-00-12-08be85f722a8a4dc92208ac212b1485994e8c5e0e8f687dd20d96bfe408dcdf8-ZB61l7.jpg)
（图 1）

求：
![img](https://up-img.yonghong.tech/pic/2020/05/31-00-12-1cfc8ead604b8f23d264db01169503752e7af4c769ae5d9c2219fa190ce6b481-imnTH0.jpg)
（图 2）

### 第一直觉

经过上面的抽象，我的第一直觉这可能是一个数学题，我回想了下数学知识，然后用数学法 AC 了。 数学就是这么简单平凡且枯燥。

然而如果没有数学的加持的情况下，我继续思考怎么做。我想是否可以枚举所有的情况（如图 1），然后对其求最大值（如图 2）。

问题转化为如何枚举所有的情况。经过了几秒钟的思考，我发现这是一个很明显的递归问题。 具体思考过程如下：

- 我们将原问题抽象为 f(n)
- 那么 f(n) 等价于 max(1 * fn(n - 1), 2 * f(n - 2), ..., (n - 1) * f(1))。

用数学公式表示就是：

![img](https://up-img.yonghong.tech/pic/2020/05/31-00-12-d4d91f13670b584553fa5077b776efeef48448a5c5dfa0bd290f6a0adf0d303a-P7DesH.jpg)
（图 3）

截止目前，是一点点数学 + 一点点递归，我们继续往下看。现在问题是不是就很简单啦？直接翻译图三为代码即可，我们来看下这个时候的代码：

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        if n == 2: return 1
        res = 0
        for i in range(1, n):
            res = max(res, max(i * self.integerBreak(n - i),i * (n - i)))
        return res
```

毫无疑问，超时了。原因很简单，就是算法中包含了太多的重复计算。如果经常看我的题解的话，这句话应该不陌生。我随便截一个我之前讲过这个知识点的图。

![img](https://up-img.yonghong.tech/pic/2020/05/31-00-12-7a5dcb22d2eddef77774922edbc58bd7d6e7acbc861f18a5ae837cd396524b2f-qFaXb1.jpg)
(图 4)

> 原文链接：https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md

大家可以尝试自己画图理解一下。

> 看到这里，有没有种殊途同归的感觉呢？

### 考虑优化

如上，我们可以考虑使用记忆化递归的方式来解决。只是用一个 hashtable 存储计算过的值即可。

```python
class Solution:
    @lru_cache()
    def integerBreak(self, n: int) -> int:
        if n == 2: return 1
        res = 0
        for i in range(1, n):
            res = max(res, max(i * self.integerBreak(n - i),i * (n - i)))
        return res
```

为了简单起见（偷懒起见），我直接用了 lru_cache 注解， 上面的代码是可以 AC 的。

### 动态规划

看到这里的同学应该发现了，这个套路是不是很熟悉？下一步就是将其改造成动态规划了。

如图 4，我们的思考方式是从顶向下，这符合人们思考问题的方式。将其改造成如下图的自底向上方式就是动态规划。

![img](https://up-img.yonghong.tech/pic/2020/05/31-00-12-85a9efe2d1d50a2fecaa9997729092a7871668254bd8ad3961509b0b01417e9d-pgKwGt.jpg)
(图 5)

现在再来看下文章开头的代码：

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        dp = [1] * (n + 1)
        for i in range(3, n + 1):
            for j in range(1, i):
                dp[i] = max(j * dp[i - j], j * (i - j), dp[i])
        return dp[n]
```

dp table 存储的是图 3 中 f(n)的值。一个自然的想法是令 dp[i] 等价于 f(i)。而由于上面分析了原问题等价于 f(n)，那么很自然的原问题也等价于 dp[n]。

而 dp[i]等价于 f(i)，那么上面针对 f(i) 写的递归公式对 dp[i] 也是适用的，我们拿来试试。

```
// 关键语句
res = max(res, max(i * self.integerBreak(n - i),i * (n - i)))
```

翻译过来就是：

```
dp[i] = max(dp[i], max(i * dp(n - i),i * (n - i)))
```

而这里的 n 是什么呢？我们说了`dp是自底向下的思考方式`，那么在达到 n 之前是看不到整体的`n` 的。因此这里的 n 实际上是 1,2,3,4... n。

自然地，我们用一层循环来生成上面一系列的 n 值。接着我们还要生成一系列的 i 值，注意到 n - i 是要大于 0 的，因此 i 只需要循环到 n - 1 即可。

思考到这里，我相信上面的代码真的是`不难得出`了。

### 关键点

- 数学抽象
- 递归分析
- 记忆化递归
- 动态规划

### 代码

python

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        dp = [1] * (n + 1)
        for i in range(3, n + 1):
            for j in range(1, i):
                dp[i] = max(j * dp[i - j], j * (i - j), dp[i])
        return dp[n]
```

java

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n+1];
        dp[2] = 1;
        for (int i = 3; i <= n; i++) {
            for (int j= 1; j < i; j++) {
                dp[i] = Math.max(dp[i], Math.max(j * dp[i-j], j * (i -j )));
            }
        }
        return dp[n];
    }
}
```

### 数学解法

![31-00-37-Wt7av3-Dw2Rdr](https://up-img.yonghong.tech/pic/2020/05/31-00-37-Wt7av3-Dw2Rdr.png)

![31-00-37-yfo4cT-hZ5f6P](https://up-img.yonghong.tech/pic/2020/05/31-00-37-yfo4cT-hZ5f6P.png)

![31-00-38-30ryCt-Bd41EW](https://up-img.yonghong.tech/pic/2020/05/31-00-38-30ryCt-Bd41EW.png)

![31-00-38-52iHsR-RLPHNH](https://up-img.yonghong.tech/pic/2020/05/31-00-38-52iHsR-RLPHNH.jpg)

![31-00-38-veJcBz-BzvzU5](https://up-img.yonghong.tech/pic/2020/05/31-00-38-veJcBz-BzvzU5.png)

python 

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        if n <= 3: return n - 1
        a, b = n // 3, n % 3
        if b == 0: return int(math.pow(3, a))
        if b == 1: return int(math.pow(3, a - 1) * 4)
        return int(math.pow(3, a) * 2)
```

java

```java
class Solution {
    public int integerBreak(int n) {
        if(n <= 3) return n - 1;
        int a = n / 3, b = n % 3;
        if(b == 0) return (int)Math.pow(3, a);
        if(b == 1) return (int)Math.pow(3, a - 1) * 4;
        return (int)Math.pow(3, a) * 2;
    }
}
```

## 下一题

题解链接：[LeetCode 628. 三个数的最大乘积](/leetcode/628/)

给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。

**示例 1:**

```
输入: [1,2,3]
输出: 6
```

**示例 2:**

```
输入: [1,2,3,4]
输出: 24
```

**注意:**

1. 给定的整型数组长度范围是[3,10^4]，数组中所有的元素范围是[-1000, 1000]。
2. 输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。

题解链接：[LeetCode 628. 三个数的最大乘积](/leetcode/628/)